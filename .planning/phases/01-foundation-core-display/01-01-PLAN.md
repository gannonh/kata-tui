---
phase: 01-foundation-core-display
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - Cargo.toml
  - src/main.rs
  - src/lib.rs
  - src/terminal.rs
autonomous: true

must_haves:
  truths:
    - "Application compiles with `cargo build`"
    - "Application exits cleanly with terminal restored"
    - "Application restores terminal on panic"
  artifacts:
    - path: "Cargo.toml"
      provides: "Project manifest with all Phase 1 dependencies"
      contains: "ratatui"
    - path: "src/terminal.rs"
      provides: "Terminal wrapper with RAII cleanup and panic hook"
      exports: ["Terminal"]
    - path: "src/main.rs"
      provides: "Entry point with tokio runtime"
      contains: "#[tokio::main]"
  key_links:
    - from: "src/main.rs"
      to: "src/terminal.rs"
      via: "Terminal::new() initialization"
      pattern: "Terminal::new"
---

<objective>
Initialize the kata-tui Rust project with proper terminal handling and panic safety.

Purpose: Establish the foundational infrastructure that ALL other code depends on. Terminal cleanup on panic is the #1 critical pitfall identified in research - this MUST be implemented first.

Output: A compilable Rust project with terminal wrapper that safely enters/exits raw mode and alternate screen, including panic hook for cleanup.
</objective>

<execution_context>
You are a Claude executor implementing a Kata plan. Execute tasks sequentially, verify each before proceeding.
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-foundation-core-display/01-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Initialize Rust project with dependencies</name>
  <files>
    Cargo.toml
    src/main.rs
    src/lib.rs
  </files>
  <action>
Create a new Rust project with `cargo init` (not `cargo new` - we're in existing directory).

Update Cargo.toml with these exact dependencies from research:

```toml
[package]
name = "kata-tui"
version = "0.1.0"
edition = "2021"
description = "Terminal dashboard for Kata project visibility"
license = "MIT"
repository = "https://github.com/user/kata-tui"

[dependencies]
# TUI Framework
ratatui = "0.30"
crossterm = { version = "0.29", features = ["event-stream"] }

# Async Runtime
tokio = { version = "1", features = ["full"] }
tokio-util = "0.7"
futures = "0.3"

# Markdown Parsing
pulldown-cmark = "0.13"

# Serialization
serde = { version = "1.0", features = ["derive"] }
serde_yaml = "0.9"

# Error Handling
color-eyre = "0.5"

# CLI
clap = { version = "4.5", features = ["derive"] }

# Logging
tracing = "0.1"
tracing-subscriber = { version = "0.3", features = ["env-filter"] }
tracing-appender = "0.2"

[dev-dependencies]
insta = "1"
```

Create src/lib.rs with module declarations (placeholder):
```rust
pub mod terminal;
```

Create minimal src/main.rs that sets up tokio runtime:
```rust
use color_eyre::Result;

#[tokio::main]
async fn main() -> Result<()> {
    color_eyre::install()?;
    println!("kata-tui starting...");
    Ok(())
}
```
  </action>
  <verify>
Run `cargo build` - should compile without errors.
Run `cargo run` - should print "kata-tui starting..." and exit cleanly.
  </verify>
  <done>
Project compiles and runs. Dependencies resolved. Directory structure matches research spec.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create Terminal wrapper with RAII and panic hook</name>
  <files>src/terminal.rs</files>
  <action>
Create src/terminal.rs implementing the Terminal wrapper with:

1. **Panic hook initialization** - MUST be called before any terminal setup:
```rust
fn init_panic_hook() {
    let default_panic = std::panic::take_hook();
    std::panic::set_hook(Box::new(move |info| {
        // Restore terminal FIRST before showing panic
        let _ = crossterm::terminal::disable_raw_mode();
        let _ = crossterm::execute!(
            std::io::stdout(),
            crossterm::terminal::LeaveAlternateScreen
        );
        default_panic(info);
    }));
}
```

2. **Terminal struct** wrapping ratatui::Terminal with CrosstermBackend:
```rust
pub struct Terminal {
    inner: ratatui::Terminal<CrosstermBackend<Stdout>>,
}
```

3. **Terminal::new()** that:
   - Calls init_panic_hook() first
   - Enables raw mode
   - Enters alternate screen
   - Creates CrosstermBackend and ratatui Terminal
   - Returns Result<Self>

4. **Drop impl** for RAII cleanup:
   - Disables raw mode
   - Leaves alternate screen
   - Uses `let _ =` to ignore errors during cleanup

5. **draw() method** that delegates to inner.draw()

6. **size() method** to get terminal dimensions

Use these imports:
```rust
use std::io::{self, Stdout};
use crossterm::{
    execute,
    terminal::{disable_raw_mode, enable_raw_mode, EnterAlternateScreen, LeaveAlternateScreen},
};
use ratatui::{backend::CrosstermBackend, Terminal as RatatuiTerminal};
```
  </action>
  <verify>
Run `cargo build` - should compile.
Run `cargo test` - should pass (no tests yet, but ensures compilation).
  </verify>
  <done>
Terminal wrapper compiles. Has new(), Drop, draw(), size() methods. Panic hook is installed before terminal setup.
  </done>
</task>

<task type="auto">
  <name>Task 3: Wire Terminal into main and verify cleanup</name>
  <files>src/main.rs</files>
  <action>
Update src/main.rs to:

1. Use the Terminal wrapper from lib
2. Create terminal, show a simple message, wait for any key, then exit
3. Test that terminal is restored even on early exit

```rust
use color_eyre::Result;
use kata_tui::terminal::Terminal;
use crossterm::event::{self, Event, KeyEventKind};

#[tokio::main]
async fn main() -> Result<()> {
    color_eyre::install()?;

    let mut terminal = Terminal::new()?;

    // Draw a simple frame to verify terminal works
    terminal.draw(|frame| {
        let area = frame.area();
        let text = ratatui::widgets::Paragraph::new("kata-tui initialized. Press any key to exit.");
        frame.render_widget(text, area);
    })?;

    // Wait for a key press
    loop {
        if let Event::Key(key) = event::read()? {
            if key.kind == KeyEventKind::Press {
                break;
            }
        }
    }

    Ok(())
}
```

Note: We're using KeyEventKind::Press filtering per PITFALLS.md to avoid platform-specific key event issues.
  </action>
  <verify>
Run `cargo run`:
1. Terminal should switch to alternate screen
2. Should show "kata-tui initialized. Press any key to exit."
3. Press any key - should exit cleanly
4. Terminal should be fully restored (can type normally, see previous content)

Test panic recovery:
1. Temporarily add `panic!("test")` after terminal creation
2. Run `cargo run`
3. Terminal should still be restored after panic message
4. Remove the panic line after verifying
  </verify>
  <done>
Application enters/exits terminal mode cleanly. Panic recovery works. Platform-safe key handling in place.
  </done>
</task>

</tasks>

<verification>
After completing all tasks:
1. `cargo build` compiles without warnings
2. `cargo run` shows TUI screen, exits cleanly on keypress
3. Terminal is fully restored after exit (can type, see shell history)
4. Panic during runtime still restores terminal
</verification>

<success_criteria>
- Cargo.toml has all Phase 1 dependencies
- src/terminal.rs exports Terminal struct with RAII cleanup
- Panic hook installed before terminal setup
- Application enters alternate screen and exits cleanly
- Works identically on macOS and Linux (uses crossterm abstraction)
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-core-display/01-01-SUMMARY.md`
</output>
