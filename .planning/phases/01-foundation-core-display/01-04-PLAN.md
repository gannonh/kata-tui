---
phase: 01-foundation-core-display
plan: 04
type: execute
wave: 3
depends_on: ["01-02", "01-03"]
files_modified:
  - src/lib.rs
  - src/layout.rs
  - src/components/mod.rs
  - src/components/tree_view.rs
  - src/components/detail_pane.rs
  - src/components/status_bar.rs
autonomous: true

must_haves:
  truths:
    - "User can see project hierarchy in left pane (tree view)"
    - "User can see selected item details in right pane"
    - "User can see status bar with navigation hints"
    - "Focused pane has highlighted border"
  artifacts:
    - path: "src/layout.rs"
      provides: "30/70 split layout computation"
      exports: ["compute_layout", "Layout"]
    - path: "src/components/tree_view.rs"
      provides: "Left pane tree view widget"
      exports: ["TreeView"]
    - path: "src/components/detail_pane.rs"
      provides: "Right pane detail widget"
      exports: ["DetailPane"]
    - path: "src/components/status_bar.rs"
      provides: "Bottom status bar widget"
      exports: ["StatusBar"]
  key_links:
    - from: "src/components/tree_view.rs"
      to: "src/data/roadmap.rs"
      via: "renders Phase/Requirement data"
      pattern: "Phase|Requirement"
    - from: "src/components/detail_pane.rs"
      to: "src/data/*.rs"
      via: "displays selected item content"
      pattern: "Project|Phase|Requirement"
    - from: "src/layout.rs"
      to: "ratatui::layout"
      via: "Layout constraint computation"
      pattern: "Constraint|Direction|Layout"
---

<objective>
Create the layout system and UI components: tree view, detail pane, and status bar.

Purpose: These components render the visual interface. The tree view shows project hierarchy (phases, requirements), the detail pane shows selected item content, and the status bar provides context and keybinding hints.

Output: Three renderable components and a layout system that positions them in a 30/70 split with status bar.
</objective>

<execution_context>
You are a Claude executor implementing a Kata plan. Execute tasks sequentially, verify each before proceeding.
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-foundation-core-display/01-RESEARCH.md
@.planning/phases/01-foundation-core-display/01-02-SUMMARY.md
@.planning/phases/01-foundation-core-display/01-03-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create layout computation</name>
  <files>src/layout.rs</files>
  <action>
Create src/layout.rs with layout computation for the two-pane layout:

```rust
use ratatui::layout::{Constraint, Direction, Layout as RatatuiLayout, Rect};

/// Computed layout areas
#[derive(Debug, Clone, Copy)]
pub struct Layout {
    /// Left pane (tree view) - 30% width
    pub tree: Rect,
    /// Right pane (detail) - 70% width
    pub detail: Rect,
    /// Bottom status bar - 1 line
    pub status_bar: Rect,
}

/// Minimum terminal size for proper display
pub const MIN_WIDTH: u16 = 60;
pub const MIN_HEIGHT: u16 = 16;

/// Narrow terminal threshold (reduce tree to 25%)
pub const NARROW_WIDTH: u16 = 80;

/// Compute layout for the given terminal area
pub fn compute_layout(area: Rect) -> Layout {
    // First split: main area and status bar
    let vertical = RatatuiLayout::default()
        .direction(Direction::Vertical)
        .constraints([
            Constraint::Min(1),    // Main content
            Constraint::Length(1), // Status bar
        ])
        .split(area);

    let main_area = vertical[0];
    let status_bar = vertical[1];

    // Determine tree width percentage based on terminal width
    let tree_percent = if area.width < NARROW_WIDTH { 25 } else { 30 };

    // Second split: tree and detail panes
    let horizontal = RatatuiLayout::default()
        .direction(Direction::Horizontal)
        .constraints([
            Constraint::Percentage(tree_percent),
            Constraint::Percentage(100 - tree_percent),
        ])
        .split(main_area);

    Layout {
        tree: horizontal[0],
        detail: horizontal[1],
        status_bar,
    }
}

/// Check if terminal is too small
pub fn is_terminal_too_small(area: Rect) -> bool {
    area.width < MIN_WIDTH || area.height < MIN_HEIGHT
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_compute_layout_standard() {
        let area = Rect::new(0, 0, 100, 30);
        let layout = compute_layout(area);

        // Tree should be ~30%
        assert!(layout.tree.width >= 29 && layout.tree.width <= 31);
        // Detail should be ~70%
        assert!(layout.detail.width >= 69 && layout.detail.width <= 71);
        // Status bar should be 1 line
        assert_eq!(layout.status_bar.height, 1);
    }

    #[test]
    fn test_compute_layout_narrow() {
        let area = Rect::new(0, 0, 70, 20);
        let layout = compute_layout(area);

        // Tree should be ~25% for narrow terminals
        assert!(layout.tree.width >= 16 && layout.tree.width <= 19);
    }

    #[test]
    fn test_terminal_too_small() {
        assert!(is_terminal_too_small(Rect::new(0, 0, 50, 20)));
        assert!(is_terminal_too_small(Rect::new(0, 0, 80, 10)));
        assert!(!is_terminal_too_small(Rect::new(0, 0, 80, 20)));
    }
}
```

Update src/lib.rs:
```rust
pub mod data;
pub mod event;
pub mod layout;
pub mod state;
pub mod terminal;
pub mod update;
```
  </action>
  <verify>
Run `cargo build` - should compile.
Run `cargo test layout` - layout tests should pass.
  </verify>
  <done>
Layout computation creates 30/70 split (25/75 for narrow terminals). Status bar is 1 line at bottom. Size checking implemented.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create UI components</name>
  <files>
    src/components/mod.rs
    src/components/tree_view.rs
    src/components/detail_pane.rs
    src/components/status_bar.rs
  </files>
  <action>
Create src/components/ directory and component files.

**src/components/mod.rs:**
```rust
pub mod detail_pane;
pub mod status_bar;
pub mod tree_view;

pub use detail_pane::DetailPane;
pub use status_bar::StatusBar;
pub use tree_view::TreeView;
```

**src/components/tree_view.rs:**
```rust
use ratatui::{
    buffer::Buffer,
    layout::Rect,
    style::{Color, Modifier, Style},
    text::{Line, Span},
    widgets::{Block, Borders, List, ListItem, ListState, StatefulWidget, Widget},
};

use crate::data::{Phase, PlanningData, Requirement};
use crate::state::FocusedPane;

/// Tree item types for the hierarchical view
#[derive(Debug, Clone)]
pub enum TreeItem {
    Project(String),
    Phase(Phase),
    Requirement { phase_num: u8, requirement: Requirement },
}

impl TreeItem {
    pub fn to_list_item(&self) -> ListItem<'static> {
        match self {
            TreeItem::Project(name) => {
                ListItem::new(Line::from(vec![
                    Span::styled("  ", Style::default()),
                    Span::styled(name.clone(), Style::default().add_modifier(Modifier::BOLD)),
                ]))
            }
            TreeItem::Phase(phase) => {
                let status_icon = match phase.status {
                    crate::data::PhaseStatus::Complete => "[x]",
                    crate::data::PhaseStatus::InProgress => "[~]",
                    crate::data::PhaseStatus::Pending => "[ ]",
                };
                ListItem::new(Line::from(vec![
                    Span::raw(format!("  {} ", status_icon)),
                    Span::styled(
                        format!("Phase {}: {}", phase.number, phase.name),
                        Style::default().add_modifier(Modifier::BOLD),
                    ),
                ]))
            }
            TreeItem::Requirement { requirement, .. } => {
                let status_icon = match requirement.status {
                    crate::data::RequirementStatus::Complete => "[x]",
                    crate::data::RequirementStatus::InProgress => "[~]",
                    crate::data::RequirementStatus::Pending => "[ ]",
                };
                ListItem::new(Line::from(vec![
                    Span::raw(format!("    {} ", status_icon)),
                    Span::styled(&requirement.id, Style::default().fg(Color::Cyan)),
                    Span::raw(": "),
                    Span::raw(truncate_text(&requirement.description, 30)),
                ]))
            }
        }
    }
}

/// Truncate text to max_len with ellipsis
fn truncate_text(text: &str, max_len: usize) -> String {
    if text.len() <= max_len {
        text.to_string()
    } else {
        format!("{}...", &text[..max_len.saturating_sub(3)])
    }
}

/// Build flat list of tree items from planning data
pub fn build_tree_items(data: &PlanningData) -> Vec<TreeItem> {
    let mut items = Vec::new();

    // Add project as root
    if !data.project.name.is_empty() {
        items.push(TreeItem::Project(data.project.name.clone()));
    }

    // Add phases and their requirements
    for phase in &data.roadmap.phases {
        items.push(TreeItem::Phase(phase.clone()));

        for req in &phase.requirements {
            items.push(TreeItem::Requirement {
                phase_num: phase.number,
                requirement: req.clone(),
            });
        }
    }

    items
}

/// Tree view widget
pub struct TreeView<'a> {
    items: &'a [TreeItem],
    focused: bool,
}

impl<'a> TreeView<'a> {
    pub fn new(items: &'a [TreeItem], focused: bool) -> Self {
        Self { items, focused }
    }
}

impl<'a> StatefulWidget for TreeView<'a> {
    type State = ListState;

    fn render(self, area: Rect, buf: &mut Buffer, state: &mut Self::State) {
        let border_style = if self.focused {
            Style::default().fg(Color::Cyan)
        } else {
            Style::default().fg(Color::DarkGray)
        };

        let block = Block::default()
            .title(" Project ")
            .borders(Borders::ALL)
            .border_style(border_style);

        let list_items: Vec<ListItem> = self.items.iter().map(|i| i.to_list_item()).collect();

        let list = List::new(list_items)
            .block(block)
            .highlight_style(
                Style::default()
                    .bg(Color::DarkGray)
                    .add_modifier(Modifier::BOLD),
            )
            .highlight_symbol("> ");

        StatefulWidget::render(list, area, buf, state);
    }
}
```

**src/components/detail_pane.rs:**
```rust
use ratatui::{
    buffer::Buffer,
    layout::Rect,
    style::{Color, Modifier, Style},
    text::{Line, Span, Text},
    widgets::{Block, Borders, Paragraph, Widget, Wrap},
};

use crate::components::tree_view::TreeItem;
use crate::data::PlanningData;

/// Detail pane widget showing selected item content
pub struct DetailPane<'a> {
    selected_item: Option<&'a TreeItem>,
    data: &'a PlanningData,
    focused: bool,
    scroll: u16,
}

impl<'a> DetailPane<'a> {
    pub fn new(
        selected_item: Option<&'a TreeItem>,
        data: &'a PlanningData,
        focused: bool,
        scroll: u16,
    ) -> Self {
        Self {
            selected_item,
            data,
            focused,
            scroll,
        }
    }

    fn build_content(&self) -> Text<'static> {
        match self.selected_item {
            None => Text::raw("No item selected"),
            Some(TreeItem::Project(_)) => self.build_project_content(),
            Some(TreeItem::Phase(phase)) => self.build_phase_content(phase),
            Some(TreeItem::Requirement { requirement, phase_num }) => {
                self.build_requirement_content(requirement, *phase_num)
            }
        }
    }

    fn build_project_content(&self) -> Text<'static> {
        let project = &self.data.project;
        let mut lines = vec![
            Line::from(vec![
                Span::styled(&project.name, Style::default().add_modifier(Modifier::BOLD)),
            ]),
            Line::from(""),
        ];

        if !project.description.is_empty() {
            lines.push(Line::from(vec![
                Span::styled("Core Value: ", Style::default().fg(Color::Yellow)),
            ]));
            lines.push(Line::from(project.description.clone()));
            lines.push(Line::from(""));
        }

        if !project.problem.is_empty() {
            lines.push(Line::from(vec![
                Span::styled("Problem: ", Style::default().fg(Color::Yellow)),
            ]));
            lines.push(Line::from(project.problem.clone()));
            lines.push(Line::from(""));
        }

        if !project.solution.is_empty() {
            lines.push(Line::from(vec![
                Span::styled("Solution: ", Style::default().fg(Color::Yellow)),
            ]));
            lines.push(Line::from(project.solution.clone()));
        }

        Text::from(lines)
    }

    fn build_phase_content(&self, phase: &crate::data::Phase) -> Text<'static> {
        let mut lines = vec![
            Line::from(vec![
                Span::styled(
                    format!("Phase {}: {}", phase.number, phase.name),
                    Style::default().add_modifier(Modifier::BOLD),
                ),
            ]),
            Line::from(""),
            Line::from(vec![
                Span::styled("Goal: ", Style::default().fg(Color::Yellow)),
            ]),
            Line::from(phase.goal.clone()),
            Line::from(""),
            Line::from(vec![
                Span::styled("Requirements:", Style::default().fg(Color::Yellow)),
            ]),
        ];

        for req in &phase.requirements {
            let status = match req.status {
                crate::data::RequirementStatus::Complete => "[x]",
                crate::data::RequirementStatus::InProgress => "[~]",
                crate::data::RequirementStatus::Pending => "[ ]",
            };
            lines.push(Line::from(format!("  {} {}: {}", status, req.id, req.description)));
        }

        // Add completion stats
        let complete = phase.requirements.iter()
            .filter(|r| r.status == crate::data::RequirementStatus::Complete)
            .count();
        let total = phase.requirements.len();
        lines.push(Line::from(""));
        lines.push(Line::from(vec![
            Span::styled("Progress: ", Style::default().fg(Color::Yellow)),
            Span::raw(format!("{}/{} requirements complete ({:.0}%)",
                complete, total, phase.completion_percentage())),
        ]));

        Text::from(lines)
    }

    fn build_requirement_content(
        &self,
        req: &crate::data::Requirement,
        phase_num: u8,
    ) -> Text<'static> {
        let status_text = match req.status {
            crate::data::RequirementStatus::Complete => "Complete",
            crate::data::RequirementStatus::InProgress => "In Progress",
            crate::data::RequirementStatus::Pending => "Pending",
        };

        let status_color = match req.status {
            crate::data::RequirementStatus::Complete => Color::Green,
            crate::data::RequirementStatus::InProgress => Color::Yellow,
            crate::data::RequirementStatus::Pending => Color::Gray,
        };

        Text::from(vec![
            Line::from(vec![
                Span::styled(&req.id, Style::default().add_modifier(Modifier::BOLD).fg(Color::Cyan)),
            ]),
            Line::from(""),
            Line::from(vec![
                Span::styled("Status: ", Style::default().fg(Color::Yellow)),
                Span::styled(status_text, Style::default().fg(status_color)),
            ]),
            Line::from(""),
            Line::from(vec![
                Span::styled("Phase: ", Style::default().fg(Color::Yellow)),
                Span::raw(format!("{}", phase_num)),
            ]),
            Line::from(""),
            Line::from(vec![
                Span::styled("Description:", Style::default().fg(Color::Yellow)),
            ]),
            Line::from(req.description.clone()),
        ])
    }
}

impl<'a> Widget for DetailPane<'a> {
    fn render(self, area: Rect, buf: &mut Buffer) {
        let border_style = if self.focused {
            Style::default().fg(Color::Cyan)
        } else {
            Style::default().fg(Color::DarkGray)
        };

        let title = match self.selected_item {
            Some(TreeItem::Project(_)) => " Project Details ",
            Some(TreeItem::Phase(p)) => Box::leak(format!(" Phase {} ", p.number).into_boxed_str()),
            Some(TreeItem::Requirement { requirement, .. }) => {
                Box::leak(format!(" {} ", requirement.id).into_boxed_str())
            }
            None => " Details ",
        };

        let block = Block::default()
            .title(title)
            .borders(Borders::ALL)
            .border_style(border_style);

        let content = self.build_content();
        let paragraph = Paragraph::new(content)
            .block(block)
            .wrap(Wrap { trim: true })
            .scroll((self.scroll, 0));

        paragraph.render(area, buf);
    }
}
```

**src/components/status_bar.rs:**
```rust
use ratatui::{
    buffer::Buffer,
    layout::Rect,
    style::{Color, Style},
    text::{Line, Span},
    widgets::{Paragraph, Widget},
};

use crate::data::PlanningState;
use crate::state::FocusedPane;

/// Status bar widget showing current state and keybinding hints
pub struct StatusBar<'a> {
    state: &'a PlanningState,
    focused_pane: FocusedPane,
}

impl<'a> StatusBar<'a> {
    pub fn new(state: &'a PlanningState, focused_pane: FocusedPane) -> Self {
        Self { state, focused_pane }
    }
}

impl<'a> Widget for StatusBar<'a> {
    fn render(self, area: Rect, buf: &mut Buffer) {
        let pane_indicator = match self.focused_pane {
            FocusedPane::Tree => "Tree",
            FocusedPane::Detail => "Detail",
        };

        let phase_info = if self.state.current_phase > 0 {
            format!("Phase {} | {} | {}",
                self.state.current_phase,
                self.state.current_phase_name,
                self.state.status)
        } else {
            "No project loaded".to_string()
        };

        let line = Line::from(vec![
            Span::styled(
                format!(" {} ", pane_indicator),
                Style::default().fg(Color::Black).bg(Color::Cyan),
            ),
            Span::raw(" "),
            Span::styled(phase_info, Style::default().fg(Color::White)),
            Span::raw(" | "),
            Span::styled("q", Style::default().fg(Color::Yellow)),
            Span::raw(":quit "),
            Span::styled("j/k", Style::default().fg(Color::Yellow)),
            Span::raw(":nav "),
            Span::styled("Tab", Style::default().fg(Color::Yellow)),
            Span::raw(":switch "),
        ]);

        let paragraph = Paragraph::new(line)
            .style(Style::default().bg(Color::DarkGray));

        paragraph.render(area, buf);
    }
}
```

Update src/lib.rs:
```rust
pub mod components;
pub mod data;
pub mod event;
pub mod layout;
pub mod state;
pub mod terminal;
pub mod update;
```
  </action>
  <verify>
Run `cargo build` - should compile.
Check that all components are exported from components/mod.rs.
  </verify>
  <done>
Tree view shows project hierarchy with status icons. Detail pane shows content for selected item. Status bar shows current state and keybindings. Focus indicated by border color.
  </done>
</task>

</tasks>

<verification>
After completing all tasks:
1. `cargo build` compiles without warnings
2. `cargo test` passes all tests
3. Layout computes correct 30/70 split
4. TreeView renders phases and requirements hierarchically
5. DetailPane shows appropriate content for each item type
6. StatusBar shows phase info and keybinding hints
7. Focus is indicated by cyan/gray border color
</verification>

<success_criteria>
- Layout computation handles standard and narrow terminals
- Tree view shows project -> phases -> requirements hierarchy
- Detail pane content adapts to selected item type
- Status bar shows context (phase, status) and keybindings
- Focused pane has highlighted border (cyan vs gray)
- All widgets use ratatui's rendering system correctly
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-core-display/01-04-SUMMARY.md`
</output>
