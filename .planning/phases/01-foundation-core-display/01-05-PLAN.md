---
phase: 01-foundation-core-display
plan: 05
type: execute
wave: 4
depends_on: ["01-02", "01-03", "01-04"]
files_modified:
  - src/lib.rs
  - src/view.rs
  - src/app.rs
  - src/main.rs
autonomous: false

must_haves:
  truths:
    - "User can run `kata-tui` and see .planning/ files as structured data"
    - "User can navigate between phases using j/k or arrow keys"
    - "User can see highlighted border on the focused pane"
    - "User can view details of selected item in right pane"
    - "Application exits cleanly on q or Esc"
  artifacts:
    - path: "src/view.rs"
      provides: "View function that composes all components"
      exports: ["view"]
    - path: "src/app.rs"
      provides: "App struct with main event loop"
      exports: ["App", "run"]
    - path: "src/main.rs"
      provides: "Entry point wiring everything together"
      contains: "App::new"
  key_links:
    - from: "src/app.rs"
      to: "src/event.rs"
      via: "async event loop"
      pattern: "EventHandler"
    - from: "src/app.rs"
      to: "src/update.rs"
      via: "state transitions from messages"
      pattern: "update::update"
    - from: "src/view.rs"
      to: "src/components/*.rs"
      via: "renders all components"
      pattern: "TreeView|DetailPane|StatusBar"
    - from: "src/main.rs"
      to: "src/data/parser.rs"
      via: "loads planning data on startup"
      pattern: "load_planning_data"
---

<objective>
Wire everything together: view composition, App lifecycle, and main entry point with user verification.

Purpose: This is the integration plan that connects all prior work. The result is a working TUI application that satisfies all Phase 1 requirements.

Output: A fully functional kata-tui application that can be run from the command line.
</objective>

<execution_context>
You are a Claude executor implementing a Kata plan. Execute tasks sequentially, verify each before proceeding.
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-foundation-core-display/01-RESEARCH.md
@.planning/phases/01-foundation-core-display/01-02-SUMMARY.md
@.planning/phases/01-foundation-core-display/01-03-SUMMARY.md
@.planning/phases/01-foundation-core-display/01-04-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create view composition function</name>
  <files>src/view.rs</files>
  <action>
Create src/view.rs that composes all UI components:

```rust
use ratatui::Frame;

use crate::components::tree_view::{build_tree_items, TreeItem, TreeView};
use crate::components::{DetailPane, StatusBar};
use crate::data::PlanningData;
use crate::layout::{compute_layout, is_terminal_too_small};
use crate::state::{AppState, FocusedPane};

/// Render the entire UI
///
/// This is the TEA View function - it renders current state to the terminal.
pub fn view(frame: &mut Frame, state: &mut AppState, data: &PlanningData, tree_items: &[TreeItem]) {
    let area = frame.area();

    // Check terminal size
    if is_terminal_too_small(area) {
        render_size_warning(frame);
        return;
    }

    let layout = compute_layout(area);

    // Render tree view (left pane)
    let tree_focused = state.focused_pane == FocusedPane::Tree;
    let tree_view = TreeView::new(tree_items, tree_focused);
    frame.render_stateful_widget(tree_view, layout.tree, &mut state.tree_state);

    // Get selected item for detail pane
    let selected_item = state
        .tree_state
        .selected()
        .and_then(|i| tree_items.get(i));

    // Render detail pane (right pane)
    let detail_focused = state.focused_pane == FocusedPane::Detail;
    let detail_pane = DetailPane::new(selected_item, data, detail_focused, state.detail_scroll);
    frame.render_widget(detail_pane, layout.detail);

    // Render status bar (bottom)
    let status_bar = StatusBar::new(&data.state, state.focused_pane);
    frame.render_widget(status_bar, layout.status_bar);
}

/// Render terminal size warning
fn render_size_warning(frame: &mut Frame) {
    use ratatui::widgets::Paragraph;
    use ratatui::style::{Color, Style};

    let warning = Paragraph::new("Terminal too small. Please resize to at least 60x16.")
        .style(Style::default().fg(Color::Red));

    frame.render_widget(warning, frame.area());
}
```

Update src/lib.rs:
```rust
pub mod app;
pub mod components;
pub mod data;
pub mod event;
pub mod layout;
pub mod state;
pub mod terminal;
pub mod update;
pub mod view;
```
  </action>
  <verify>
Run `cargo build` - should compile (app.rs not yet created but module declared).
  </verify>
  <done>
View function composes all components. Handles terminal size check. Passes state to widgets correctly.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create App struct and main loop</name>
  <files>src/app.rs</files>
  <action>
Create src/app.rs with the App struct and async main loop:

```rust
use std::path::PathBuf;
use std::time::Duration;
use color_eyre::Result;

use crate::components::tree_view::{build_tree_items, TreeItem};
use crate::data::{load_planning_data, PlanningData};
use crate::event::{Event, EventHandler};
use crate::state::AppState;
use crate::terminal::Terminal;
use crate::update::{key_to_message, update};
use crate::view::view;

/// Application state and lifecycle manager
pub struct App {
    /// Terminal wrapper
    terminal: Terminal,
    /// Application state
    state: AppState,
    /// Planning data from .planning/ files
    data: PlanningData,
    /// Flattened tree items for rendering
    tree_items: Vec<TreeItem>,
}

impl App {
    /// Create a new App instance
    ///
    /// Loads planning data from the specified directory (or current directory if None).
    pub fn new(planning_dir: Option<PathBuf>) -> Result<Self> {
        let terminal = Terminal::new()?;

        // Determine planning directory
        let dir = planning_dir.unwrap_or_else(|| {
            std::env::current_dir()
                .unwrap_or_else(|_| PathBuf::from("."))
                .join(".planning")
        });

        // Load planning data
        let data = load_planning_data(&dir)?;

        // Build tree items
        let tree_items = build_tree_items(&data);

        // Initialize state with correct tree bounds
        let mut state = AppState::new();

        // Update the max tree items in update.rs is handled dynamically via tree_items.len()
        // For now, ensure selection is valid
        if tree_items.is_empty() {
            state.tree_state.select(None);
        }

        Ok(Self {
            terminal,
            state,
            data,
            tree_items,
        })
    }

    /// Run the application main loop
    pub async fn run(&mut self) -> Result<()> {
        // Create event handler with 250ms tick rate
        let mut events = EventHandler::new(Duration::from_millis(250));

        // Main loop
        loop {
            // Render current state
            self.terminal.draw(|frame| {
                view(frame, &mut self.state, &self.data, &self.tree_items);
            })?;

            // Wait for next event
            if let Some(event) = events.next().await {
                match event {
                    Event::Key(key) => {
                        if let Some(message) = key_to_message(key) {
                            // Update state and check bounds
                            update(&mut self.state, message);

                            // Clamp selection to valid range
                            if let Some(selected) = self.state.tree_state.selected() {
                                if selected >= self.tree_items.len() {
                                    self.state.tree_state.select(
                                        Some(self.tree_items.len().saturating_sub(1))
                                    );
                                }
                            }

                            // Check if we should quit
                            if self.state.should_quit {
                                break;
                            }
                        }
                    }
                    Event::Resize(_, _) => {
                        // Terminal resize - just redraw (handled by next loop iteration)
                    }
                    Event::Tick => {
                        // Periodic tick - could refresh data here in future
                    }
                }
            }
        }

        Ok(())
    }
}

/// Run the application
pub async fn run(planning_dir: Option<PathBuf>) -> Result<()> {
    let mut app = App::new(planning_dir)?;
    app.run().await
}
```
  </action>
  <verify>
Run `cargo build` - should compile.
  </verify>
  <done>
App struct manages lifecycle. Main loop handles events, updates state, renders view. Clean async event handling.
  </done>
</task>

<task type="auto">
  <name>Task 3: Update main.rs with CLI and app startup</name>
  <files>src/main.rs</files>
  <action>
Update src/main.rs with CLI argument parsing and app startup:

```rust
use std::path::PathBuf;
use clap::Parser;
use color_eyre::Result;

/// Terminal dashboard for Kata project visibility
#[derive(Parser, Debug)]
#[command(author, version, about, long_about = None)]
struct Args {
    /// Path to .planning directory (defaults to ./.planning)
    #[arg(short, long)]
    planning_dir: Option<PathBuf>,
}

#[tokio::main]
async fn main() -> Result<()> {
    color_eyre::install()?;

    // Parse CLI arguments
    let args = Args::parse();

    // Run the application
    kata_tui::app::run(args.planning_dir).await
}
```
  </action>
  <verify>
Run `cargo build` - should compile.
Run `cargo run -- --help` - should show CLI help with --planning-dir option.
  </verify>
  <done>
CLI parsing with clap. Supports --planning-dir option. Starts app correctly.
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>
Complete kata-tui Phase 1 application with:
- Two-pane layout (tree view + detail pane)
- Keyboard navigation (j/k/up/down, Tab to switch panes, q to quit)
- Parsing of .planning/ files (PROJECT.md, ROADMAP.md, STATE.md)
- Focus indicators (highlighted border on active pane)
- Status bar with context and keybinding hints
  </what-built>
  <how-to-verify>
1. Navigate to a directory with a .planning/ folder (this project works):
   ```bash
   cd /Users/gannonhall/dev/oss/kata-burner/kata-tui
   cargo run
   ```

2. Verify initial display:
   - Left pane shows project tree (project name, phases, requirements)
   - Right pane shows details of selected item
   - Bottom status bar shows phase info and keybindings
   - Tree pane has cyan border (focused)

3. Test navigation:
   - Press `j` or Down arrow - selection moves down
   - Press `k` or Up arrow - selection moves up
   - Selection change updates detail pane content

4. Test pane switching:
   - Press `Tab` - focus moves to detail pane (cyan border moves)
   - Press `Tab` again - focus returns to tree pane
   - Press `l` or Right arrow from tree - moves to detail pane

5. Test detail pane scrolling:
   - Select an item with lots of content
   - Switch to detail pane with Tab
   - Press `j`/`k` or PageUp/PageDown to scroll

6. Test quit:
   - Press `q` or `Esc` - application exits cleanly
   - Terminal is fully restored (can type normally)

7. Verify on both macOS and Linux if possible:
   - Same behavior on both platforms
   - No weird key event issues

Expected outcome: All success criteria from Phase 1 are met.
  </how-to-verify>
  <resume-signal>Type "approved" if Phase 1 requirements are met, or describe any issues found.</resume-signal>
</task>

</tasks>

<verification>
After completing all tasks:
1. `cargo build` compiles without warnings
2. `cargo run` launches the TUI application
3. User can see PROJECT.md, ROADMAP.md, STATE.md content
4. Navigation works with vim keys (j/k) and arrow keys
5. Tab switches between panes
6. Focus indicated by border color
7. q/Esc exits cleanly with terminal restored
</verification>

<success_criteria>
Phase 1 success criteria (from ROADMAP.md):
1. User can run `kata-tui` in a project directory and see PROJECT.md, ROADMAP.md, STATE.md content
2. User can navigate between phases/milestones using j/k or arrow keys
3. User sees a highlighted border indicating which element has focus
4. User can view details of any selected item in a right-side pane
5. Application runs identically on macOS and Linux terminals
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-core-display/01-05-SUMMARY.md`
</output>
