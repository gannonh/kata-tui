---
phase: 01-foundation-core-display
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - src/lib.rs
  - src/state.rs
  - src/event.rs
  - src/update.rs
autonomous: true

must_haves:
  truths:
    - "Application responds to keyboard navigation (j/k/up/down)"
    - "Application responds to quit command (q/Esc)"
    - "State changes are tracked via Message enum"
  artifacts:
    - path: "src/state.rs"
      provides: "AppState model and Message enum for TEA pattern"
      exports: ["AppState", "Message", "FocusedPane"]
    - path: "src/event.rs"
      provides: "Async event handler for keyboard input"
      exports: ["EventHandler", "Event"]
    - path: "src/update.rs"
      provides: "Update function for state transitions"
      exports: ["update"]
  key_links:
    - from: "src/event.rs"
      to: "crossterm::event::EventStream"
      via: "tokio stream for async events"
      pattern: "EventStream"
    - from: "src/update.rs"
      to: "src/state.rs"
      via: "Message -> AppState mutation"
      pattern: "fn update.*Message.*AppState"
---

<objective>
Implement the TEA (The Elm Architecture) core: State, Message, Update, and Event handling.

Purpose: TEA is the recommended architecture for ratatui apps. It provides predictable state management and clear data flow. This plan establishes the backbone that all UI components will use.

Output: Working async event loop that converts keyboard input to Messages and updates AppState accordingly.
</objective>

<execution_context>
You are a Claude executor implementing a Kata plan. Execute tasks sequentially, verify each before proceeding.
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-foundation-core-display/01-RESEARCH.md
@.planning/phases/01-foundation-core-display/01-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create State and Message types</name>
  <files>src/state.rs</files>
  <action>
Create src/state.rs with the TEA Model (state) and Message enum:

```rust
use ratatui::widgets::ListState;

/// Which pane currently has focus
#[derive(Debug, Clone, Copy, PartialEq, Eq, Default)]
pub enum FocusedPane {
    #[default]
    Tree,
    Detail,
}

/// Application state - the single source of truth (TEA Model)
#[derive(Debug)]
pub struct AppState {
    /// Whether the application should quit
    pub should_quit: bool,

    /// Currently focused pane
    pub focused_pane: FocusedPane,

    /// Tree view selection state (which item is selected)
    pub tree_state: ListState,

    /// Index of selected item in flattened tree (for detail pane)
    pub selected_index: usize,

    /// Scroll offset for detail pane
    pub detail_scroll: u16,
}

impl Default for AppState {
    fn default() -> Self {
        let mut tree_state = ListState::default();
        tree_state.select(Some(0)); // Select first item by default

        Self {
            should_quit: false,
            focused_pane: FocusedPane::Tree,
            tree_state,
            selected_index: 0,
            detail_scroll: 0,
        }
    }
}

impl AppState {
    pub fn new() -> Self {
        Self::default()
    }
}

/// Messages that can trigger state changes (TEA Message)
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum Message {
    /// Navigate up in the current view
    NavigateUp,
    /// Navigate down in the current view
    NavigateDown,
    /// Navigate left (collapse tree node or switch to tree pane)
    NavigateLeft,
    /// Navigate right (expand tree node or switch to detail pane)
    NavigateRight,
    /// Select current item / expand
    Select,
    /// Switch focus between panes
    SwitchPane,
    /// Scroll detail pane up
    ScrollUp,
    /// Scroll detail pane down
    ScrollDown,
    /// Quit the application
    Quit,
    /// Tick event for periodic updates (future use)
    Tick,
}
```

Update src/lib.rs to include the module:
```rust
pub mod state;
pub mod terminal;
```
  </action>
  <verify>
Run `cargo build` - should compile.
Run `cargo doc --open` and verify AppState and Message are documented.
  </verify>
  <done>
AppState and Message types defined. FocusedPane enum for pane focus tracking. ListState for tree selection.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create async Event handler</name>
  <files>src/event.rs</files>
  <action>
Create src/event.rs with async event handling using tokio and crossterm:

```rust
use std::time::Duration;
use crossterm::event::{Event as CrosstermEvent, EventStream, KeyEvent, KeyEventKind};
use futures::{FutureExt, StreamExt};
use tokio::sync::mpsc;

/// Application events
#[derive(Debug, Clone)]
pub enum Event {
    /// Keyboard input
    Key(KeyEvent),
    /// Terminal resize
    Resize(u16, u16),
    /// Periodic tick (for future animations/updates)
    Tick,
}

/// Async event handler
///
/// Spawns a background task that reads terminal events and sends them
/// through a channel. This keeps the main loop non-blocking.
pub struct EventHandler {
    rx: mpsc::UnboundedReceiver<Event>,
    // Keep handle to abort on drop
    _task: tokio::task::JoinHandle<()>,
}

impl EventHandler {
    /// Create a new event handler with the given tick rate
    pub fn new(tick_rate: Duration) -> Self {
        let (tx, rx) = mpsc::unbounded_channel();

        let task = tokio::spawn(async move {
            let mut reader = EventStream::new();
            let mut tick_interval = tokio::time::interval(tick_rate);

            loop {
                let tick_delay = tick_interval.tick();
                let crossterm_event = reader.next().fuse();

                tokio::select! {
                    _ = tick_delay => {
                        if tx.send(Event::Tick).is_err() {
                            break;
                        }
                    }
                    maybe_event = crossterm_event => {
                        match maybe_event {
                            Some(Ok(event)) => {
                                match event {
                                    CrosstermEvent::Key(key) => {
                                        // CRITICAL: Only handle Press events for cross-platform compatibility
                                        // Windows sends Press+Release, macOS/Linux may vary
                                        if key.kind == KeyEventKind::Press {
                                            if tx.send(Event::Key(key)).is_err() {
                                                break;
                                            }
                                        }
                                    }
                                    CrosstermEvent::Resize(w, h) => {
                                        if tx.send(Event::Resize(w, h)).is_err() {
                                            break;
                                        }
                                    }
                                    _ => {}
                                }
                            }
                            Some(Err(_)) => break,
                            None => break,
                        }
                    }
                }
            }
        });

        Self { rx, _task: task }
    }

    /// Get the next event, waiting asynchronously
    pub async fn next(&mut self) -> Option<Event> {
        self.rx.recv().await
    }
}
```

Key points from PITFALLS.md implemented:
- Uses EventStream for async (non-blocking) events
- Filters for KeyEventKind::Press only (platform compatibility)
- Uses mpsc channel so main loop stays async
- Tick events for future periodic updates

Update src/lib.rs:
```rust
pub mod event;
pub mod state;
pub mod terminal;
```
  </action>
  <verify>
Run `cargo build` - should compile.
Check that EventHandler uses tokio::spawn (non-blocking pattern from pitfalls).
  </verify>
  <done>
EventHandler created with async event stream. Press-only filtering. Tick support. Non-blocking main loop pattern.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create Update function for state transitions</name>
  <files>src/update.rs</files>
  <action>
Create src/update.rs implementing the TEA Update function:

```rust
use crate::state::{AppState, FocusedPane, Message};

/// Maximum number of items in tree (will be dynamic later)
const MAX_TREE_ITEMS: usize = 10;

/// TEA Update function - handles all state transitions
///
/// Takes the current state and a message, returns whether state changed.
/// This is the ONLY place state mutations happen (TEA pattern).
pub fn update(state: &mut AppState, message: Message) -> bool {
    match message {
        Message::Quit => {
            state.should_quit = true;
            true
        }

        Message::NavigateUp => {
            match state.focused_pane {
                FocusedPane::Tree => {
                    let current = state.tree_state.selected().unwrap_or(0);
                    if current > 0 {
                        state.tree_state.select(Some(current - 1));
                        state.selected_index = current - 1;
                        true
                    } else {
                        false
                    }
                }
                FocusedPane::Detail => {
                    if state.detail_scroll > 0 {
                        state.detail_scroll = state.detail_scroll.saturating_sub(1);
                        true
                    } else {
                        false
                    }
                }
            }
        }

        Message::NavigateDown => {
            match state.focused_pane {
                FocusedPane::Tree => {
                    let current = state.tree_state.selected().unwrap_or(0);
                    // MAX_TREE_ITEMS is placeholder, will be replaced with actual data length
                    if current < MAX_TREE_ITEMS.saturating_sub(1) {
                        state.tree_state.select(Some(current + 1));
                        state.selected_index = current + 1;
                        true
                    } else {
                        false
                    }
                }
                FocusedPane::Detail => {
                    state.detail_scroll = state.detail_scroll.saturating_add(1);
                    true
                }
            }
        }

        Message::NavigateLeft => {
            if state.focused_pane == FocusedPane::Detail {
                state.focused_pane = FocusedPane::Tree;
                true
            } else {
                // In tree: would collapse node (future)
                false
            }
        }

        Message::NavigateRight => {
            if state.focused_pane == FocusedPane::Tree {
                state.focused_pane = FocusedPane::Detail;
                true
            } else {
                // In detail: no action
                false
            }
        }

        Message::Select => {
            // Enter key: expand/collapse in tree (future) or switch to detail
            if state.focused_pane == FocusedPane::Tree {
                state.focused_pane = FocusedPane::Detail;
                true
            } else {
                false
            }
        }

        Message::SwitchPane => {
            state.focused_pane = match state.focused_pane {
                FocusedPane::Tree => FocusedPane::Detail,
                FocusedPane::Detail => FocusedPane::Tree,
            };
            true
        }

        Message::ScrollUp => {
            if state.detail_scroll > 0 {
                state.detail_scroll = state.detail_scroll.saturating_sub(3);
                true
            } else {
                false
            }
        }

        Message::ScrollDown => {
            state.detail_scroll = state.detail_scroll.saturating_add(3);
            true
        }

        Message::Tick => {
            // Future: refresh data, animations
            false
        }
    }
}

/// Convert keyboard event to Message
pub fn key_to_message(key: crossterm::event::KeyEvent) -> Option<Message> {
    use crossterm::event::KeyCode;

    match key.code {
        // Quit
        KeyCode::Char('q') | KeyCode::Esc => Some(Message::Quit),

        // Navigation - vim style
        KeyCode::Char('j') | KeyCode::Down => Some(Message::NavigateDown),
        KeyCode::Char('k') | KeyCode::Up => Some(Message::NavigateUp),
        KeyCode::Char('h') | KeyCode::Left => Some(Message::NavigateLeft),
        KeyCode::Char('l') | KeyCode::Right => Some(Message::NavigateRight),

        // Selection
        KeyCode::Enter => Some(Message::Select),
        KeyCode::Tab => Some(Message::SwitchPane),

        // Scrolling
        KeyCode::PageUp => Some(Message::ScrollUp),
        KeyCode::PageDown => Some(Message::ScrollDown),

        _ => None,
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_quit_sets_flag() {
        let mut state = AppState::new();
        assert!(!state.should_quit);

        update(&mut state, Message::Quit);

        assert!(state.should_quit);
    }

    #[test]
    fn test_navigate_down_increments_selection() {
        let mut state = AppState::new();
        assert_eq!(state.tree_state.selected(), Some(0));

        update(&mut state, Message::NavigateDown);

        assert_eq!(state.tree_state.selected(), Some(1));
    }

    #[test]
    fn test_navigate_up_at_zero_stays() {
        let mut state = AppState::new();
        assert_eq!(state.tree_state.selected(), Some(0));

        let changed = update(&mut state, Message::NavigateUp);

        assert!(!changed);
        assert_eq!(state.tree_state.selected(), Some(0));
    }

    #[test]
    fn test_switch_pane_toggles() {
        let mut state = AppState::new();
        assert_eq!(state.focused_pane, FocusedPane::Tree);

        update(&mut state, Message::SwitchPane);
        assert_eq!(state.focused_pane, FocusedPane::Detail);

        update(&mut state, Message::SwitchPane);
        assert_eq!(state.focused_pane, FocusedPane::Tree);
    }
}
```

Update src/lib.rs:
```rust
pub mod event;
pub mod state;
pub mod terminal;
pub mod update;
```
  </action>
  <verify>
Run `cargo build` - should compile.
Run `cargo test` - all tests should pass.
  </verify>
  <done>
Update function handles all navigation messages. key_to_message converts keyboard to messages. Unit tests verify state transitions.
  </done>
</task>

</tasks>

<verification>
After completing all tasks:
1. `cargo build` compiles without warnings
2. `cargo test` passes all 4 unit tests
3. Module structure: state.rs (types), event.rs (async events), update.rs (state transitions)
4. TEA pattern complete: Model (AppState), Message, Update function
</verification>

<success_criteria>
- AppState holds all application state in one place (no RefCell/Mutex)
- Message enum covers all user actions
- EventHandler is fully async (non-blocking)
- Key events filtered for Press only (platform safe)
- Update function is pure (only mutates state based on message)
- Unit tests verify state transitions
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-core-display/01-02-SUMMARY.md`
</output>
