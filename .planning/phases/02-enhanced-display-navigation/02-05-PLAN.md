---
phase: 02-enhanced-display-navigation
plan: 05
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - Cargo.toml
  - src/state.rs
  - src/update.rs
  - src/view.rs
  - src/search.rs
  - src/lib.rs
  - src/components/mod.rs
  - src/components/search_input.rs
autonomous: true
user_setup: []

must_haves:
  truths:
    - "User can press / to enter search mode"
    - "User can type to filter tree items"
    - "Matching items are highlighted or filtered"
    - "User can press Esc to exit search"
    - "User can press Enter to confirm and navigate to first match"
  artifacts:
    - path: "src/search.rs"
      provides: "Fuzzy matching with nucleo-matcher"
      contains: "nucleo_matcher"
    - path: "src/components/search_input.rs"
      provides: "Search input widget"
      exports: ["SearchInput"]
    - path: "src/state.rs"
      provides: "Search query and results state"
      contains: "search_query"
  key_links:
    - from: "src/view.rs"
      to: "InputMode::Search"
      via: "conditional search input render"
      pattern: "state\\.input_mode.*Search"
    - from: "src/search.rs"
      to: "nucleo_matcher"
      via: "fuzzy matching integration"
      pattern: "Matcher::new"
---

<objective>
Implement fuzzy search/filter functionality allowing users to quickly find items in the tree view.

Purpose: Enable rapid navigation in large projects by filtering to matching items rather than scrolling.

Output: / enters search mode, typing filters tree, Esc exits, Enter confirms selection.
</objective>

<execution_context>
@./references/execute-plan.md
@./references/summary-template.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-enhanced-display-navigation/02-RESEARCH.md
@.planning/phases/02-enhanced-display-navigation/02-01-SUMMARY.md
@src/state.rs
@src/update.rs
@src/view.rs
@src/components/tree_view.rs
@Cargo.toml
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add nucleo-matcher dependency and create search module</name>
  <files>Cargo.toml, src/search.rs, src/lib.rs</files>
  <action>
1. Add nucleo-matcher to Cargo.toml dependencies:
   ```toml
   # Fuzzy Search
   nucleo-matcher = "0.3"
   ```

2. Create src/search.rs with fuzzy matching logic:
   ```rust
   use nucleo_matcher::{
       pattern::{CaseMatching, Normalization, Pattern},
       Matcher, Utf32Str,
   };

   /// Fuzzy matcher for tree items
   pub struct FuzzyMatcher {
       matcher: Matcher,
   }

   impl FuzzyMatcher {
       pub fn new() -> Self {
           Self {
               matcher: Matcher::new(nucleo_matcher::Config::DEFAULT),
           }
       }

       /// Match a query against a haystack, returning score if matched
       /// Higher score = better match
       pub fn score(&mut self, query: &str, haystack: &str) -> Option<u32> {
           if query.is_empty() {
               return Some(0); // Empty query matches everything
           }

           let pattern = Pattern::new(
               query,
               CaseMatching::Ignore,
               Normalization::Smart,
               nucleo_matcher::pattern::AtomKind::Fuzzy,
           );

           let mut haystack_buf = Vec::new();
           let haystack_str = Utf32Str::new(haystack, &mut haystack_buf);

           pattern.score(haystack_str, &mut self.matcher)
       }

       /// Check if query matches haystack
       pub fn matches(&mut self, query: &str, haystack: &str) -> bool {
           self.score(query, haystack).is_some()
       }
   }

   impl Default for FuzzyMatcher {
       fn default() -> Self {
           Self::new()
       }
   }

   #[cfg(test)]
   mod tests {
       use super::*;

       #[test]
       fn test_empty_query_matches_all() {
           let mut matcher = FuzzyMatcher::new();
           assert!(matcher.matches("", "anything"));
       }

       #[test]
       fn test_exact_match() {
           let mut matcher = FuzzyMatcher::new();
           assert!(matcher.matches("phase", "Phase 1"));
       }

       #[test]
       fn test_fuzzy_match() {
           let mut matcher = FuzzyMatcher::new();
           assert!(matcher.matches("ph1", "Phase 1"));
       }

       #[test]
       fn test_no_match() {
           let mut matcher = FuzzyMatcher::new();
           assert!(!matcher.matches("xyz", "Phase 1"));
       }

       #[test]
       fn test_case_insensitive() {
           let mut matcher = FuzzyMatcher::new();
           assert!(matcher.matches("PHASE", "phase"));
       }
   }
   ```

3. In src/lib.rs, add the module:
   ```rust
   pub mod search;
   ```
  </action>
  <verify>
- `cargo build` succeeds (nucleo-matcher compiles)
- `cargo test search` passes all tests
- FuzzyMatcher correctly matches/doesn't match expected patterns
  </verify>
  <done>nucleo-matcher dependency added. FuzzyMatcher wrapper provides case-insensitive fuzzy matching with scoring.</done>
</task>

<task type="auto">
  <name>Task 2: Add search state to AppState</name>
  <files>src/state.rs, src/update.rs</files>
  <action>
1. In src/state.rs, add search-related fields to AppState:
   ```rust
   /// Current search query (empty when not searching)
   pub search_query: String,

   /// Indices of tree items that match the search query
   pub search_matches: Vec<usize>,

   /// Current match index (for cycling through matches)
   pub current_match: usize,
   ```

2. Initialize in Default impl:
   ```rust
   search_query: String::new(),
   search_matches: Vec::new(),
   current_match: 0,
   ```

3. Add Message variants for search:
   ```rust
   /// Character input for search
   SearchInput(char),
   /// Backspace in search
   SearchBackspace,
   /// Confirm search (navigate to match)
   ConfirmSearch,
   /// Navigate to next match
   NextMatch,
   /// Navigate to previous match
   PrevMatch,
   ```

4. In src/update.rs, add handlers for search messages:
   ```rust
   Message::EnterSearchMode => {
       state.input_mode = InputMode::Search;
       state.search_query.clear();
       state.search_matches.clear();
       state.current_match = 0;
       true
   }

   Message::ExitSearchMode => {
       state.input_mode = InputMode::Normal;
       // Keep search_query so user can see what they searched
       // Clear on next search entry
       true
   }

   Message::SearchInput(c) => {
       state.search_query.push(c);
       // Matches will be computed in view/app layer with access to tree_items
       true
   }

   Message::SearchBackspace => {
       state.search_query.pop();
       true
   }

   Message::ConfirmSearch => {
       if !state.search_matches.is_empty() {
           // Select the current match
           let match_idx = state.search_matches[state.current_match];
           state.tree_state.select(Some(match_idx));
           state.selected_index = match_idx;
       }
       state.input_mode = InputMode::Normal;
       true
   }

   Message::NextMatch => {
       if !state.search_matches.is_empty() {
           state.current_match = (state.current_match + 1) % state.search_matches.len();
           let match_idx = state.search_matches[state.current_match];
           state.tree_state.select(Some(match_idx));
           state.selected_index = match_idx;
       }
       true
   }

   Message::PrevMatch => {
       if !state.search_matches.is_empty() {
           state.current_match = if state.current_match == 0 {
               state.search_matches.len() - 1
           } else {
               state.current_match - 1
           };
           let match_idx = state.search_matches[state.current_match];
           state.tree_state.select(Some(match_idx));
           state.selected_index = match_idx;
       }
       true
   }
   ```
  </action>
  <verify>
- `cargo build` succeeds
- `cargo test` passes
- Search state fields exist in AppState
- Message variants exist for all search operations
  </verify>
  <done>AppState has search_query, search_matches, current_match fields. Message enum has all search-related variants with handlers.</done>
</task>

<task type="auto">
  <name>Task 3: Create search input component and wire up UI</name>
  <files>src/components/search_input.rs, src/components/mod.rs, src/update.rs, src/view.rs, src/app.rs</files>
  <action>
1. Create src/components/search_input.rs:
   ```rust
   use ratatui::{
       buffer::Buffer,
       layout::Rect,
       style::{Color, Style},
       widgets::{Block, Borders, Paragraph, Widget},
   };

   /// Search input widget displayed at bottom of screen
   pub struct SearchInput<'a> {
       query: &'a str,
       match_count: usize,
       current_match: usize,
   }

   impl<'a> SearchInput<'a> {
       pub fn new(query: &'a str, match_count: usize, current_match: usize) -> Self {
           Self {
               query,
               match_count,
               current_match,
           }
       }
   }

   impl<'a> Widget for SearchInput<'a> {
       fn render(self, area: Rect, buf: &mut Buffer) {
           let match_info = if self.match_count > 0 {
               format!(" [{}/{}]", self.current_match + 1, self.match_count)
           } else if !self.query.is_empty() {
               " [no matches]".to_string()
           } else {
               String::new()
           };

           let content = format!("/{}{}", self.query, match_info);

           let style = if self.match_count > 0 || self.query.is_empty() {
               Style::default().fg(Color::Cyan)
           } else {
               Style::default().fg(Color::Red)
           };

           let search_bar = Paragraph::new(content)
               .style(style)
               .block(
                   Block::default()
                       .borders(Borders::ALL)
                       .border_style(Style::default().fg(Color::Cyan))
                       .title(" Search (Esc to cancel, Enter to confirm) "),
               );

           search_bar.render(area, buf);
       }
   }
   ```

2. In src/components/mod.rs, add:
   ```rust
   pub mod search_input;
   pub use search_input::SearchInput;
   ```

3. In src/update.rs, update key_to_message for Search mode:
   ```rust
   InputMode::Search => match key.code {
       KeyCode::Esc => Some(Message::ExitSearchMode),
       KeyCode::Enter => Some(Message::ConfirmSearch),
       KeyCode::Backspace => Some(Message::SearchBackspace),
       KeyCode::Char(c) => Some(Message::SearchInput(c)),
       KeyCode::Down | KeyCode::Tab => Some(Message::NextMatch),
       KeyCode::Up | KeyCode::BackTab => Some(Message::PrevMatch),
       _ => None,
   },
   ```

4. Add / key binding in Normal mode (in key_to_message):
   ```rust
   // In Normal mode match:
   KeyCode::Char('/') => Some(Message::EnterSearchMode),
   ```

5. In src/view.rs (or src/app.rs), compute search matches when query changes:
   ```rust
   use crate::search::FuzzyMatcher;

   // In view() or before view():
   // Update search matches based on query
   fn compute_search_matches(
       tree_items: &[TreeItem],
       query: &str,
       matcher: &mut FuzzyMatcher,
   ) -> Vec<usize> {
       if query.is_empty() {
           return Vec::new();
       }

       tree_items
           .iter()
           .enumerate()
           .filter_map(|(idx, item)| {
               let text = match item {
                   TreeItem::Project(name) => name.clone(),
                   TreeItem::Phase(phase) => format!("Phase {}: {}", phase.number, phase.name),
                   TreeItem::Requirement { requirement, .. } => {
                       format!("{}: {}", requirement.id, requirement.description)
                   }
               };

               if matcher.matches(query, &text) {
                   Some(idx)
               } else {
                   None
               }
           })
           .collect()
   }
   ```

   Call this after search_query changes and store in state.search_matches.
   This needs to happen in app.rs event loop after update(), with mutable access to state.

6. In src/view.rs, render search input when in Search mode:
   ```rust
   // At the end of view(), after status bar:
   if state.input_mode == InputMode::Search {
       // Overlay search input at bottom (over status bar area)
       let search_input = SearchInput::new(
           &state.search_query,
           state.search_matches.len(),
           state.current_match,
       );
       frame.render_widget(search_input, layout.status_bar);
   }
   ```

7. In src/app.rs, create a FuzzyMatcher and update matches after state changes:
   ```rust
   let mut fuzzy_matcher = FuzzyMatcher::new();

   // In event loop, after update() and tree rebuild:
   if state.input_mode == InputMode::Search {
       state.search_matches = compute_search_matches(&tree_items, &state.search_query, &mut fuzzy_matcher);
       // Clamp current_match
       if !state.search_matches.is_empty() && state.current_match >= state.search_matches.len() {
           state.current_match = 0;
       }
   }
   ```

8. Optionally highlight matching items in tree view (can be done later as enhancement).
  </action>
  <verify>
- `cargo build` succeeds
- `cargo test` passes
- `cargo run`:
  - Press / to enter search mode
  - Search input appears at bottom
  - Type to search (e.g., "phase 2")
  - Matches shown as [1/N]
  - Up/Down/Tab cycles through matches
  - Enter confirms and navigates to match
  - Esc exits search mode
  </verify>
  <done>Search UI complete. / enters search, typing filters, Enter confirms, Esc exits. Fuzzy matching works. NAV-05 requirement satisfied.</done>
</task>

</tasks>

<verification>
1. `cargo build --release` compiles without errors
2. `cargo test` - all tests pass including fuzzy matcher tests
3. `cargo clippy -- -D warnings` - no warnings
4. Manual verification:
   - Launch with `cargo run`
   - Press / - search input appears
   - Type "req" - matches requirement items
   - Type "phase 1" - matches Phase 1
   - Match count shows [1/N]
   - Tab/Down cycles to next match, selection follows
   - Enter confirms, exits search, stays on selected item
   - Esc cancels search
   - Empty search shows all items (no filtering)
</verification>

<success_criteria>
- nucleo-matcher dependency added to Cargo.toml
- FuzzyMatcher wrapper in src/search.rs with tests
- SearchInput component in src/components/search_input.rs
- / key enters search mode
- Typing updates search query with fuzzy matching
- Match count displayed
- Up/Down/Tab cycles through matches
- Enter confirms and navigates to match
- Esc exits search mode
- NAV-05 requirement fully satisfied
</success_criteria>

<output>
After completion, create `.planning/phases/02-enhanced-display-navigation/02-05-SUMMARY.md`
</output>
