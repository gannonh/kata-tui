---
phase: 02-enhanced-display-navigation
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/state.rs
  - src/update.rs
  - src/components/tree_view.rs
  - src/view.rs
  - src/app.rs
autonomous: true

must_haves:
  truths:
    - "User sees expand/collapse arrows on phases with children"
    - "User can press Enter or Right arrow to expand a collapsed phase"
    - "User can press Enter or Left arrow to collapse an expanded phase"
    - "Collapsed phases hide their requirements"
    - "Selection stays valid after collapse"
  artifacts:
    - path: "src/state.rs"
      provides: "Expand state tracking with HashSet"
      contains: "expanded_phases"
    - path: "src/components/tree_view.rs"
      provides: "Filtered tree building with expand state"
      contains: "build_tree_items.*expanded"
  key_links:
    - from: "src/components/tree_view.rs"
      to: "AppState.expanded_phases"
      via: "build_tree_items parameter"
      pattern: "expanded.*HashSet"
    - from: "src/update.rs"
      to: "expanded_phases"
      via: "ToggleExpand message handler"
      pattern: "Message::ToggleExpand"
---

<objective>
Implement expand/collapse functionality for tree nodes so users can focus on specific phases.

Purpose: Allow users to collapse phases they're not interested in, reducing visual clutter and making navigation faster.

Output: Phases show expand/collapse indicators, Enter/arrows toggle expansion state, collapsed phases hide their requirements.
</objective>

<execution_context>
@./references/execute-plan.md
@./references/summary-template.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-enhanced-display-navigation/02-RESEARCH.md
@src/state.rs
@src/update.rs
@src/components/tree_view.rs
@src/view.rs
@src/app.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add expand state tracking to AppState</name>
  <files>src/state.rs, src/update.rs</files>
  <action>
1. In src/state.rs, add import at top:
   ```rust
   use std::collections::HashSet;
   ```

2. Add field to AppState struct (after detail_scroll):
   ```rust
   /// Which phase numbers are currently expanded (showing requirements)
   pub expanded_phases: HashSet<u8>,
   ```

3. In Default impl, initialize with all phases expanded by default:
   ```rust
   expanded_phases: HashSet::new(), // Empty = all collapsed initially
   ```

   OR for better UX, expand phases by default. We'll start collapsed so users see the expand feature.

4. Add helper methods to AppState impl:
   ```rust
   pub fn toggle_expansion(&mut self, phase_num: u8) {
       if self.expanded_phases.contains(&phase_num) {
           self.expanded_phases.remove(&phase_num);
       } else {
           self.expanded_phases.insert(phase_num);
       }
   }

   pub fn is_expanded(&self, phase_num: u8) -> bool {
       self.expanded_phases.contains(&phase_num)
   }
   ```

5. Add Message variant in state.rs:
   ```rust
   /// Toggle expand/collapse of a phase
   ToggleExpand(u8),
   ```

6. In src/update.rs, update the Message::Select handler to toggle expansion when on a Phase:
   - This requires knowing what item is selected, which means we need tree_items
   - For now, add ToggleExpand handler:
   ```rust
   Message::ToggleExpand(phase_num) => {
       state.toggle_expansion(phase_num);
       true
   }
   ```

7. Update NavigateLeft handler to collapse current phase if in Tree pane and item is a Phase:
   - We'll wire this up in Task 2 when we have access to tree_items in the event loop

8. Update NavigateRight handler to expand current phase if in Tree pane and item is a Phase:
   - Same as above - wire in Task 2
  </action>
  <verify>
- `cargo build` succeeds
- `cargo test` passes
- `cargo clippy` has no warnings
  </verify>
  <done>AppState has expanded_phases HashSet with toggle_expansion and is_expanded methods. ToggleExpand message variant exists.</done>
</task>

<task type="auto">
  <name>Task 2: Update tree building and navigation for expand/collapse</name>
  <files>src/components/tree_view.rs, src/view.rs, src/app.rs, src/update.rs</files>
  <action>
1. In src/components/tree_view.rs, modify build_tree_items to accept expanded state:
   ```rust
   use std::collections::HashSet;

   /// Build flat list of tree items from planning data, respecting expand state
   pub fn build_tree_items(data: &PlanningData, expanded: &HashSet<u8>) -> Vec<TreeItem> {
       let mut items = Vec::new();

       // Add project as root
       if !data.project.name.is_empty() {
           items.push(TreeItem::Project(data.project.name.clone()));
       }

       // Add phases and their requirements (only if expanded)
       for phase in &data.roadmap.phases {
           items.push(TreeItem::Phase(phase.clone()));

           // Only include requirements if this phase is expanded
           if expanded.contains(&phase.number) {
               for req in &phase.requirements {
                   items.push(TreeItem::Requirement {
                       phase_num: phase.number,
                       requirement: req.clone(),
                   });
               }
           }
       }

       items
   }
   ```

2. Update TreeItem::to_list_item() for Phase to show expand indicator:
   - This needs to know if the phase is expanded
   - Add a parameter or make it a method on a new struct

   Better approach: Add helper function to get expand icon:
   ```rust
   fn get_expand_icon(expanded: bool, has_children: bool) -> &'static str {
       if !has_children {
           "  "  // No indicator if no children
       } else if expanded {
           "v "  // Down arrow for expanded
       } else {
           "> "  // Right arrow for collapsed
       }
   }
   ```

   Modify TreeItem to include expand state for rendering, OR modify TreeView to pass expanded state.

   Simplest: Change TreeView to accept expanded HashSet and pass to render:
   ```rust
   pub struct TreeView<'a> {
       items: &'a [TreeItem],
       focused: bool,
       expanded: &'a HashSet<u8>,
       phases_with_requirements: &'a HashSet<u8>,  // Which phases have children
   }
   ```

   Then in render, build list items with expand awareness.

3. Update src/view.rs to pass expanded state to build_tree_items:
   ```rust
   // In view() function, tree_items should be built with expanded state
   // But tree_items is passed in from app.rs, so update the call site
   ```

4. Update src/app.rs to rebuild tree_items when state changes:
   - In the main loop, rebuild tree_items after each update
   - Pass &state.expanded_phases to build_tree_items
   ```rust
   let tree_items = build_tree_items(&data, &state.expanded_phases);
   ```

5. After any expand/collapse change, clamp selection to valid range:
   ```rust
   // In update.rs after ToggleExpand:
   // We need access to the new tree_items count
   // This is tricky - we need to know how many items after rebuild

   // Alternative: Handle in app.rs after update returns true:
   // After update, if tree_items length changed, clamp selection
   if let Some(selected) = state.tree_state.selected() {
       if selected >= tree_items.len() {
           state.tree_state.select(Some(tree_items.len().saturating_sub(1)));
           state.selected_index = tree_items.len().saturating_sub(1);
       }
   }
   ```

6. Wire up Select/Enter to toggle when on Phase:
   In app.rs event loop, after getting the message but before calling update:
   ```rust
   // Check if we need to convert Select to ToggleExpand
   let message = if let Some(Message::Select) = message {
       if state.focused_pane == FocusedPane::Tree {
           if let Some(idx) = state.tree_state.selected() {
               if let Some(TreeItem::Phase(phase)) = tree_items.get(idx) {
                   Some(Message::ToggleExpand(phase.number))
               } else {
                   message
               }
           } else {
               message
           }
       } else {
           message
       }
   } else {
       message
   };
   ```

7. Similarly wire NavigateLeft (when in tree on Phase) to collapse, NavigateRight to expand.
  </action>
  <verify>
- `cargo build` succeeds
- `cargo test` passes
- `cargo run`:
  - Phases start collapsed (or expanded - decide on UX)
  - Pressing Enter on a Phase toggles its expansion
  - Requirements appear/disappear under phases
  - Selection stays valid after collapse
  - Left arrow on expanded Phase collapses it
  - Right arrow on collapsed Phase expands it
  </verify>
  <done>Tree nodes expand and collapse. Enter toggles, arrows expand/collapse directionally. Requirements hidden when phase collapsed. Selection remains valid. NAV-03 requirement satisfied.</done>
</task>

<task type="auto">
  <name>Task 3: Add unit tests for expand/collapse</name>
  <files>src/update.rs, src/components/tree_view.rs</files>
  <action>
1. In src/update.rs, add tests:
   ```rust
   #[test]
   fn test_toggle_expand_adds_to_set() {
       let mut state = AppState::new();
       assert!(!state.is_expanded(1));

       state.toggle_expansion(1);

       assert!(state.is_expanded(1));
   }

   #[test]
   fn test_toggle_expand_removes_from_set() {
       let mut state = AppState::new();
       state.toggle_expansion(1);  // Add
       assert!(state.is_expanded(1));

       state.toggle_expansion(1);  // Remove

       assert!(!state.is_expanded(1));
   }
   ```

2. In src/components/tree_view.rs, add test module if not present:
   ```rust
   #[cfg(test)]
   mod tests {
       use super::*;
       use crate::data::{Phase, PhaseStatus, PlanningData, Project, Roadmap, Requirement, RequirementStatus};

       fn mock_data() -> PlanningData {
           PlanningData {
               project: Project { name: "Test".to_string(), ..Default::default() },
               roadmap: Roadmap {
                   phases: vec![
                       Phase {
                           number: 1,
                           name: "Phase One".to_string(),
                           requirements: vec![
                               Requirement {
                                   id: "REQ-01".to_string(),
                                   description: "Test req".to_string(),
                                   status: RequirementStatus::Pending,
                               }
                           ],
                           ..Default::default()
                       },
                       Phase {
                           number: 2,
                           name: "Phase Two".to_string(),
                           requirements: vec![],
                           ..Default::default()
                       },
                   ],
                   ..Default::default()
               },
               ..Default::default()
           }
       }

       #[test]
       fn test_build_tree_collapsed_hides_requirements() {
           let data = mock_data();
           let expanded = HashSet::new();  // All collapsed

           let items = build_tree_items(&data, &expanded);

           // Should have: Project + 2 Phases = 3 items (no requirements)
           assert_eq!(items.len(), 3);
       }

       #[test]
       fn test_build_tree_expanded_shows_requirements() {
           let data = mock_data();
           let mut expanded = HashSet::new();
           expanded.insert(1);  // Expand phase 1

           let items = build_tree_items(&data, &expanded);

           // Should have: Project + Phase1 + Req + Phase2 = 4 items
           assert_eq!(items.len(), 4);
       }
   }
   ```

3. Ensure all tests pass and cover edge cases.
  </action>
  <verify>
- `cargo test` passes with new tests
- Test coverage for expand/collapse behavior
  </verify>
  <done>Unit tests verify expand/collapse state tracking and tree building respects expansion state.</done>
</task>

</tasks>

<verification>
1. `cargo build --release` compiles without errors
2. `cargo test` - all tests pass including new expand/collapse tests
3. `cargo clippy -- -D warnings` - no warnings
4. Manual verification:
   - Launch with `cargo run`
   - Navigate to a Phase with requirements
   - Press Enter - requirements should toggle visibility
   - Press Left on expanded Phase - should collapse
   - Press Right on collapsed Phase - should expand
   - Collapse a phase while a child is selected - selection should move to phase
</verification>

<success_criteria>
- expanded_phases HashSet exists in AppState
- toggle_expansion and is_expanded methods work correctly
- build_tree_items respects expansion state
- Enter key toggles phase expansion
- Left/Right arrows expand/collapse in tree pane
- Selection clamped to valid range after collapse
- Visual expand/collapse indicators shown (> for collapsed, v for expanded)
- Unit tests cover expand/collapse logic
- NAV-03 requirement fully satisfied
</success_criteria>

<output>
After completion, create `.planning/phases/02-enhanced-display-navigation/02-02-SUMMARY.md`
</output>
