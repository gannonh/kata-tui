---
phase: 02-enhanced-display-navigation
plan: 04
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - src/update.rs
  - src/view.rs
  - src/components/mod.rs
  - src/components/help_overlay.rs
autonomous: true

must_haves:
  truths:
    - "User can press ? to show help overlay"
    - "Help overlay shows all keybindings"
    - "User can press ? or Esc or q to dismiss help"
    - "Help overlay renders centered over existing content"
  artifacts:
    - path: "src/components/help_overlay.rs"
      provides: "Help overlay widget"
      exports: ["HelpOverlay"]
    - path: "src/view.rs"
      provides: "Conditional help overlay rendering"
      contains: "InputMode::Help"
  key_links:
    - from: "src/view.rs"
      to: "InputMode::Help"
      via: "conditional render check"
      pattern: "state\\.input_mode.*Help"
    - from: "src/update.rs"
      to: "Message::ShowHelp"
      via: "? key binding"
      pattern: "Char\\('\\?'\\).*ShowHelp"
---

<objective>
Implement help overlay that shows all keybindings when user presses ?.

Purpose: Provide discoverability for keyboard shortcuts without requiring users to read documentation.

Output: New help_overlay.rs component, ? key toggles help visibility, overlay shows centered over content.
</objective>

<execution_context>
@./references/execute-plan.md
@./references/summary-template.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-enhanced-display-navigation/02-RESEARCH.md
@.planning/phases/02-enhanced-display-navigation/02-01-SUMMARY.md
@src/state.rs
@src/update.rs
@src/view.rs
@src/components/mod.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create help overlay component</name>
  <files>src/components/help_overlay.rs, src/components/mod.rs</files>
  <action>
1. Create new file src/components/help_overlay.rs:
   ```rust
   use ratatui::{
       buffer::Buffer,
       layout::{Constraint, Flex, Layout, Rect},
       style::{Color, Modifier, Style},
       text::{Line, Span},
       widgets::{Block, Borders, Clear, Paragraph, Widget},
   };

   /// Help overlay showing all keybindings
   pub struct HelpOverlay;

   impl HelpOverlay {
       pub fn new() -> Self {
           Self
       }

       /// Calculate centered popup area
       fn popup_area(area: Rect, percent_x: u16, percent_y: u16) -> Rect {
           let vertical = Layout::vertical([Constraint::Percentage(percent_y)])
               .flex(Flex::Center);
           let horizontal = Layout::horizontal([Constraint::Percentage(percent_x)])
               .flex(Flex::Center);
           let [area] = vertical.areas(area);
           let [area] = horizontal.areas(area);
           area
       }
   }

   impl Default for HelpOverlay {
       fn default() -> Self {
           Self::new()
       }
   }

   impl Widget for HelpOverlay {
       fn render(self, area: Rect, buf: &mut Buffer) {
           // Calculate centered popup (60% width, 70% height)
           let popup_area = Self::popup_area(area, 60, 70);

           // Clear the background
           Clear.render(popup_area, buf);

           // Build help content
           let help_lines = vec![
               Line::from(Span::styled(
                   "Keybindings",
                   Style::default().add_modifier(Modifier::BOLD | Modifier::UNDERLINED),
               )),
               Line::from(""),
               Line::from(vec![
                   Span::styled("Navigation", Style::default().add_modifier(Modifier::BOLD)),
               ]),
               Line::from("  j / Down      Move down"),
               Line::from("  k / Up        Move up"),
               Line::from("  h / Left      Collapse / Move to tree"),
               Line::from("  l / Right     Expand / Move to detail"),
               Line::from("  Enter         Toggle expand / Select"),
               Line::from("  Tab           Switch pane focus"),
               Line::from(""),
               Line::from(vec![
                   Span::styled("Scrolling", Style::default().add_modifier(Modifier::BOLD)),
               ]),
               Line::from("  PageUp        Scroll detail up"),
               Line::from("  PageDown      Scroll detail down"),
               Line::from(""),
               Line::from(vec![
                   Span::styled("Actions", Style::default().add_modifier(Modifier::BOLD)),
               ]),
               Line::from("  /             Search / Filter"),
               Line::from("  ?             Toggle this help"),
               Line::from("  q / Esc       Quit (or close overlay)"),
               Line::from(""),
               Line::from(Span::styled(
                   "Press ? or Esc to close",
                   Style::default().fg(Color::DarkGray),
               )),
           ];

           let help = Paragraph::new(help_lines)
               .block(
                   Block::default()
                       .title(" Help ")
                       .borders(Borders::ALL)
                       .border_style(Style::default().fg(Color::Cyan)),
               )
               .style(Style::default().bg(Color::Black));

           help.render(popup_area, buf);
       }
   }
   ```

2. In src/components/mod.rs, add the module and export:
   ```rust
   pub mod help_overlay;

   pub use help_overlay::HelpOverlay;
   ```
  </action>
  <verify>
- `cargo build` succeeds
- File exists at src/components/help_overlay.rs
- Module properly exported from components/mod.rs
  </verify>
  <done>HelpOverlay widget exists with centered popup rendering and comprehensive keybinding list.</done>
</task>

<task type="auto">
  <name>Task 2: Wire up ? key and conditional rendering</name>
  <files>src/update.rs, src/view.rs</files>
  <action>
1. In src/update.rs, update key_to_message to handle ? key:
   ```rust
   pub fn key_to_message(key: crossterm::event::KeyEvent, input_mode: InputMode) -> Option<Message> {
       use crossterm::event::KeyCode;

       match input_mode {
           InputMode::Normal => match key.code {
               // Quit
               KeyCode::Char('q') | KeyCode::Esc => Some(Message::Quit),

               // Help
               KeyCode::Char('?') => Some(Message::ShowHelp),

               // Navigation - vim style
               KeyCode::Char('j') | KeyCode::Down => Some(Message::NavigateDown),
               KeyCode::Char('k') | KeyCode::Up => Some(Message::NavigateUp),
               KeyCode::Char('h') | KeyCode::Left => Some(Message::NavigateLeft),
               KeyCode::Char('l') | KeyCode::Right => Some(Message::NavigateRight),

               // Selection
               KeyCode::Enter => Some(Message::Select),
               KeyCode::Tab => Some(Message::SwitchPane),

               // Scrolling
               KeyCode::PageUp => Some(Message::ScrollUp),
               KeyCode::PageDown => Some(Message::ScrollDown),

               _ => None,
           },
           InputMode::Help => match key.code {
               KeyCode::Esc | KeyCode::Char('?') | KeyCode::Char('q') => Some(Message::HideHelp),
               _ => None,  // Ignore other keys in help mode
           },
           InputMode::Search => {
               // Will be implemented in Plan 05
               match key.code {
                   KeyCode::Esc => Some(Message::ExitSearchMode),
                   _ => None,
               }
           }
       }
   }
   ```

2. NOTE: The current key_to_message doesn't take InputMode. We need to:
   - Update the function signature to accept InputMode
   - Update all call sites (in app.rs or event handler)

   Find where key_to_message is called (likely app.rs) and update:
   ```rust
   // Before:
   let message = key_to_message(key);

   // After:
   let message = key_to_message(key, state.input_mode);
   ```

3. In src/view.rs, import HelpOverlay and InputMode:
   ```rust
   use crate::components::HelpOverlay;
   use crate::state::InputMode;
   ```

4. Update view() function to conditionally render help overlay:
   ```rust
   pub fn view(frame: &mut Frame, state: &mut AppState, data: &PlanningData, tree_items: &[TreeItem]) {
       let area = frame.area();

       // Check terminal size
       if is_terminal_too_small(area) {
           render_size_warning(frame);
           return;
       }

       let layout = compute_layout(area);

       // Render tree view (left pane)
       let tree_focused = state.focused_pane == FocusedPane::Tree;
       let tree_view = TreeView::new(tree_items, tree_focused);
       frame.render_stateful_widget(tree_view, layout.tree, &mut state.tree_state);

       // Get selected item for detail pane
       let selected_item = state.tree_state.selected().and_then(|i| tree_items.get(i));

       // Render detail pane (right pane)
       let detail_focused = state.focused_pane == FocusedPane::Detail;
       let detail_pane = DetailPane::new(selected_item, data, detail_focused, state.detail_scroll);
       frame.render_widget(detail_pane, layout.detail);

       // Render status bar (bottom)
       let status_bar = StatusBar::new(&data.state, state.focused_pane);
       frame.render_widget(status_bar, layout.status_bar);

       // Render overlays based on input mode
       if state.input_mode == InputMode::Help {
           frame.render_widget(HelpOverlay::new(), area);
       }
   }
   ```

5. Update any tests that call key_to_message to pass InputMode::Normal.
  </action>
  <verify>
- `cargo build` succeeds
- `cargo test` passes
- `cargo run`:
  - Press ? to show help overlay
  - Help shows centered over content
  - Press ? or Esc to dismiss
  - While help is shown, other keys do nothing
  </verify>
  <done>? key toggles help overlay. Help shows all keybindings. Esc or ? dismisses help. NAV-04 requirement satisfied.</done>
</task>

</tasks>

<verification>
1. `cargo build --release` compiles without errors
2. `cargo test` - all tests pass
3. `cargo clippy -- -D warnings` - no warnings
4. Manual verification:
   - Launch with `cargo run`
   - Press ? - help overlay appears centered
   - Help shows navigation, scrolling, and action keybindings
   - Press Esc or ? again - help dismisses
   - While help is shown, j/k/arrows don't navigate (keys consumed)
   - Press q while help shown - closes help (or quits, decide behavior)
</verification>

<success_criteria>
- HelpOverlay component exists in src/components/help_overlay.rs
- ? key shows help overlay (InputMode::Help)
- Help overlay shows comprehensive keybinding list
- Overlay renders centered, clearing background
- Esc, ?, or q dismisses help overlay
- Other keys ignored while help is shown
- NAV-04 requirement fully satisfied
</success_criteria>

<output>
After completion, create `.planning/phases/02-enhanced-display-navigation/02-04-SUMMARY.md`
</output>
